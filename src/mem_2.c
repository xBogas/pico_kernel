#ifndef KERNEL_ENABLE_MPU

#include "kernel.h"
#include "memory.h"
#include "locks.h"
#include "terminal.h"
#include <string.h>
#include <stdlib.h>

struct next {
	struct next *next;
};

static struct {
	struct spinlock lock;
	struct next *free;
} k_mem;

struct heap {
	uint32_t size;
	struct next *end;
};

static struct heap *k_heap;

// Values generated by the linker
extern char end[];
extern char __StackLimit[];

static void free_range(void *start, void *end);

void k_mem_init(void)
{
	k_mem.free = NULL;
	init_lock(&k_mem.lock, "mem lock");
	
	
	k_heap = (struct heap *)end;
	k_heap->end = (struct next *)PG_ROUND_UP((uint32_t)end);
	k_heap->size = 0;

	printk("heap start:	%p\n", k_heap);
	printk("heap size: 	%x\n", k_heap->size);
	printk("heap end: 	%p\n", k_heap->end);

	free_range(k_heap->end, __StackLimit);
}

void k_free(void *ptr)
{
	if (((uint32_t)ptr % PAGE_SIZE) != 0 || (char *)ptr < end || (char *)ptr >= __StackLimit)
		panic("k_free: bad page ptr %p\n", ptr);

	memset(ptr, 1, PAGE_SIZE);
	struct next *tmp = (struct next *)ptr;

	acquire_lock(&k_mem.lock);
	tmp->next = k_mem.free;
	k_mem.free = tmp;
	release_lock(&k_mem.lock);
}

void *k_alloc(void)
{
	struct next *tmp;
	acquire_lock(&k_mem.lock);

	tmp = k_mem.free;
	if (tmp)
		k_mem.free = tmp->next;

	release_lock(&k_mem.lock);

	if (tmp)
		memset(tmp, 0, PAGE_SIZE);

	return (void *)tmp;
}

static void free_range(void *start, void *end)
{
	char *p = (char *)PG_ROUND_UP((uint32_t)start);

	for (; p + PAGE_SIZE < (char *)end ; p += PAGE_SIZE)
		k_free(p);
}

// newlibc malloc implementation
extern void *__real_malloc(size_t size);

//static struct mutex malloc_mutex;

//TODO:
void *__wrap_malloc(size_t size)
{
	if (size == 0)
		return NULL;

	//mutex_lock(&malloc_mutex);

	void *ptr = __real_malloc(size);

	//mutex_unlock(&malloc_mutex);

	return ptr;
}

void *_sbrk(size_t add)
{
	static char *heap_end = end;
	heap_end = end + k_heap->size;

	k_heap->size += add;
	char *new_end = heap_end + add;

	if (new_end > (char *)k_heap->end) {
		char *ptr = (char*)k_heap->end + PAGE_SIZE;
		struct next *p = (struct next *)ptr;
		if (p->next  == k_heap->end) {
			k_heap->end = p;
			p->next = NULL;
		}
		else
			return (char *)-1; // error condition
	}

	return (void *)heap_end;
}

#endif