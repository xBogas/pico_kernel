#ifndef KERNEL_ENABLE_MPU

#include "kernel.h"
#include "memory.h"
#include "locks.h"
#include "terminal.h"
#include <string.h>

struct next {
	struct next *next;
};

static struct {
	struct spinlock lock;
	struct next *free;
} k_mem;

static struct {
	void* end;
	void* start;
} k_heap;

// Values generated by the linker
extern char end[];
extern char __StackLimit[];

static void free_range(void *start, void *end);

void k_mem_init(void)
{
	k_mem.free = NULL;
	init_lock(&k_mem.lock, "mem lock");
	k_heap.start = end;
	k_heap.end = (void *)PG_ROUND_UP((uint32_t)end);

	free_range(k_heap.end, __StackLimit);
}

void k_free(void *ptr)
{
	if (((uint32_t)ptr % PAGE_SIZE) != 0 || (char *)ptr < end || (char *)ptr >= __StackLimit)
		panic("k_free: bad page ptr %p\n", ptr);

	memset(ptr, 1, PAGE_SIZE);
	struct next *tmp = (struct next *)ptr;

	acquire_lock(&k_mem.lock);
	tmp->next = k_mem.free;
	k_mem.free = tmp;
	release_lock(&k_mem.lock);
}

void *k_malloc(void)
{
	struct next *tmp;
	acquire_lock(&k_mem.lock);

	tmp = k_mem.free;
	if (tmp)
		k_mem.free = tmp->next;

	release_lock(&k_mem.lock);

	if (tmp)
		memset(tmp, 0, PAGE_SIZE);

	return (void *)tmp;
}

static void free_range(void *start, void *end)
{
	char *p = (char *)PG_ROUND_UP((uint32_t)start);
	printk("will lose %d bytes\n", (uint32_t)p - (uint32_t)start);
	for (; p + PAGE_SIZE < (char *)end ; p += PAGE_SIZE)
		k_free(p);
}


#endif