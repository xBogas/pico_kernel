#include "memory.h"
#include "locks.h"
#include "pico/printf.h"
#include "string.h"
#include "terminal.h"

#define PAGE_SIZE 128 //256(0x0100) is probably too much for pico 

#define PAGE_ALIGN(x) ((x + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1))

void free_range(void* start, void* end);
void setup_mpu(void);

struct next {
	struct next* next;
};

struct {
	struct spinlock lock;
	struct next* free;
}k_mem;

// Values generated by the linker
extern char end[];
extern char __StackLimit[];

void k_mem_init(void) 
{
	k_mem.free = NULL;
	init_lock(&k_mem.lock, "mem lock");
	free_range(end, __StackLimit);

	setup_mpu();
	printk("mpu setup done\n");
}

#include "hardware/structs/mpu.h"
#include "pico/stdlib.h"
#include "hardware/sync.h"

struct mpu_zone {
	uint32_t addr;
	uint32_t len;
	uint32_t status;
};

uint32_t *to_test;

#define MPU_CTRL_ENABLE_MASK 	_u(0x01)
#define MPU_RASR_ACCESS_POS 	_u(24)
#define MPU_RASR_SIZE_POS 		_u(1)
#define MPU_RASR_ENABLE_POS 	_u(0)

#include "RP2040.h"

void setup_mpu(void)
{
	printk("beggining mpu setup\n");

	__disable_irq();
	ARM_MPU_Disable();

	uint32_t *ptr = k_malloc();
	*ptr = 5;
	to_test = ptr;
    struct mpu_zone zone1 = {
		.addr 	= (uint32_t)ptr,
		.len 	= 0x06, // 128 bytes
		.status = ARM_MPU_AP_PRO, // no access
	};

	// zone id
	mpu_hw->rnr = 0;

	// region attributes
	mpu_hw->rbar = zone1.addr;
	mpu_hw->rasr = 	(uint32_t)zone1.status 	<< MPU_RASR_ACCESS_POS |
					(uint32_t)zone1.len 	<< MPU_RASR_SIZE_POS   |
					(uint32_t)1 			<< MPU_RASR_ENABLE_POS;

	ARM_MPU_Enable(0x04);
	__enable_irq();

	printk("test writting ...\n");
	sleep_ms(100);
	*to_test = 10;
}


void free_range(void* start, void* end) 
{
	char *p;
	p = (char*)PAGE_ALIGN((uint32_t)end) - PAGE_SIZE;

	for (; p - PAGE_SIZE > (char*)start; p -= PAGE_SIZE)
		k_free(p);
}

void k_free(void* ptr) 
{
	struct next* mem;

	if (((uint32_t)ptr % PAGE_SIZE) != 0 || (char*)ptr < end || (char*)ptr >= __StackLimit)
		panic("k_free: bad ptr %p\n", ptr);

	// will be 64 bit aligned for better performance __aeabi_memcpy8 - 4*64 = 256
	memset(ptr, 1, PAGE_SIZE);
	mem = (struct next*)ptr;

	acquire_lock(&k_mem.lock);
	mem->next = k_mem.free;
	k_mem.free = mem;
	release_lock(&k_mem.lock);
}

// allocate a page of kernel memory
void* k_malloc(void) 
{
	struct next* mem;

	acquire_lock(&k_mem.lock);
	mem = k_mem.free;
	if (mem)
		k_mem.free = mem->next;
	release_lock(&k_mem.lock);

	if (!mem)
		return NULL;

	memset(mem, 0, PAGE_SIZE);
	return (void*)mem;
}

// allocate kernel memory
// if failed return null
// and set errno ERROR CODE
void* malloc(size_t size)
{
	return NULL;//malloc(size);
}

void* calloc(size_t count, size_t size)
{
	return NULL;
}

void* realloc(void* ptr, size_t size)
{
	return NULL;
}

void free(void* ptr)
{ }


