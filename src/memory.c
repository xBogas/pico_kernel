#include "memory.h"
#include "locks.h"
#include "pico/printf.h"
#include "string.h"

#define PAGE_SIZE 128 //256(0x0100) is probably too much for pico 

#define PAGE_ALIGN(x) ((x + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1))

void free_range(void* start, void* end);


struct next {
	struct next* next;
};

struct {
	struct spinlock lock;
	struct next* free;
}k_mem;

// Values generated by the linker
extern char end[];
extern char __StackLimit[];

void k_mem_init(void) 
{
	k_mem.free = NULL;
	init_lock(&k_mem.lock, "mem lock");
	free_range(end, __StackLimit);

	printf("first block is %p\n", k_mem.free);
	printf("end is %p\n", end);
}

void free_range(void* start, void* end) 
{
	char *p;
	p = (char*)PAGE_ALIGN((uint32_t)end) - PAGE_SIZE;

	printf("kernel heap size: %d\n", (uint32_t)end - (uint32_t)start);
	for (; p - PAGE_SIZE > (char*)start; p -= PAGE_SIZE)
		k_free(p);

	printf("will lose %d bytes\n", (uint32_t)p - (uint32_t)start);
}

void k_free(void* ptr) 
{
	struct next* mem;

	if (((uint32_t)ptr % PAGE_SIZE) != 0 || (char*)ptr < end || (char*)ptr >= __StackLimit)
		panic("k_free: bad ptr %p\n", ptr);

	// will be 64 bit aligned for better performance __aeabi_memcpy8 - 4*64 = 256
	memset(ptr, 1, PAGE_SIZE);
	mem = (struct next*)ptr;

	acquire_lock(&k_mem.lock);
	mem->next = k_mem.free;
	k_mem.free = mem;
	release_lock(&k_mem.lock);
}

// allocate a page of kernel memory
void* k_malloc(void) 
{
	struct next* mem;

	acquire_lock(&k_mem.lock);
	mem = k_mem.free;
	if (mem)
		k_mem.free = mem->next;
	release_lock(&k_mem.lock);

	if (!mem)
		return NULL;

	memset(mem, 0, PAGE_SIZE);
	return (void*)mem;
}

// allocate kernel memory
// if failed return null
// and set errno ERROR CODE
void* malloc(size_t size)
{
	return NULL;//malloc(size);
}

void* calloc(size_t count, size_t size)
{
	return NULL;
}

void* realloc(void* ptr, size_t size)
{
	return NULL;
}

void free(void* ptr)
{ }


